/** A group represents a thick bordered region on a grid. Given an array of
 * points, the fractions generated for the grid, and the cells in the grid the
 * constructor will pick a random operation for the grip and display the goal
 * and operation in a cell.
 * 
 * @param points An array of points that will be members of the group
 * @param fractions A 2d array representing the generated fractions for the grid.
 * @param cells A 2d array of the cells for the table.
 */
function Group(points, fractions, cells) {
	this.points = new Array(points.length);
	for (let i = 0; i < points.length; i++) {
		this.points[i] = [points[i][0], points[i][1]];
	}

	this.cells = cells;

	if (points.length === 1) {
		possible_operations = ["constant"];
	} else if (points.length === 2) {
		possible_operations = ["+", "-", "/", "*"];
	} else {
		possible_operations = ["+", "*"];
	}

	let op_index = Math.floor(Math.random() * possible_operations.length);
	this.operation = possible_operations[op_index];

	this.determineGoal(fractions);
	this.displayLabel();
	this.drawBorders();
}

/** Given the array of fractions generated for the grid, determines the
 * operation for the group and the goal fraction.
 *
 * @param fractionArray The array of fractions generated by the grid
 */
Group.prototype.determineGoal = function(fractionArray) {
	if (this.operation === "constant") {
		let x = this.points[0][0];
		let y = this.points[0][1];
		this.goal = fractionArray[x][y].reduce();
		this.label = this.goal.toString();
	} else if (this.operation === "/" || this.operation === "-") {
		let x1 = this.points[0][0];
		let y1 = this.points[0][1];
		let x2 = this.points[1][0];
		let y2 = this.points[1][1];

		let frac1 = fractionArray[x1][y1];
		let frac2 = fractionArray[x2][y2];
		if (frac1.value() < frac2.value()) {
			let tmp = frac1;
			frac1 = frac2;
			frac2 = tmp;
		}

		if (this.operation === "/") {
			this.goal = frac1.divide(frac2).reduce();
			this.label = this.goal.toString() + " /";
		} else {
			this.goal = frac1.subtract(frac2).reduce();
			this.label = this.goal.toString() + " -";
		}
	} else if (this.operation === "*") {
		let res = new Fraction(1, 1);
		for (let i = 0; i < this.points.length; i++) {
			let x = this.points[i][0];
			let y = this.points[i][1];
			res = res.multiply(fractionArray[x][y]);
		}

		this.goal = res.reduce();
		this.label = this.goal.toString() + " x";
	} else if (this.operation === "+") {
		let res = new Fraction(0, 1);
		for (let i = 0; i < this.points.length; i++) {
			let x = this.points[i][0];
			let y = this.points[i][1];
			res = res.add(fractionArray[x][y]);
		}

		this.goal = res.reduce();
		this.label = this.goal.toString() + " +";
	}
}

/** displays the label for this group in the top most and left most cell.
 */
Group.prototype.displayLabel = function() {
	let topLeftPoint = this.points[0];

	for (let i = 1; i < this.points.length; i++) {
		let currPoint = this.points[i];
		if (currPoint[1] < topLeftPoint[1] || 
			(topLeftPoint[1] === currPoint[1] && currPoint[0] < topLeftPoint[0])) {
			topLeftPoint = currPoint;
		}
	}

	this.cells[topLeftPoint[0]][topLeftPoint[1]].setLabel(this.label);
}

/** Returns true if this group contains the given point. */
Group.prototype.containsPoint = function(point) {
	for (let i = 0; i < this.points.length; i++) {
		if (this.points[i][0] === point[0] && this.points[i][1] === point[1])
			return true;
	}

	return false;
}

/** Draws the thick borders around the points in this group, but not between 
 * them.
 */
Group.prototype.drawBorders = function() {
	for (let i = 0; i < this.points.length; i++) {
		let x = this.points[i][0];
		let y = this.points[i][1];
		let right = [x + 1, y];
		let down = [x, y + 1];
		this.cells[x][y].drawBorders(
			!this.containsPoint(right),
			!this.containsPoint(down));
	}
}

/** Checks to see if the cells in the group are a valid solution based on the
 * operation and goal for this group.  If the goal and the current value are not
 * equal, will display all member cells as invalid. Returns true if the
 * calculated value equals the goal and false otherwise.
 *
 * @return True if this group is valid and false otherwise
 */
Group.prototype.validate = function() {
	let groupValue;
	if (this.operation === "constant") {
		let x = this.points[0][0];
		let y = this.points[0][1];
		groupValue = this.cells[x][y].getFraction();

	} else if (this.operation === "/" || this.operation === "-") {
		let x1 = this.points[0][0];
		let y1 = this.points[0][1];
		let x2 = this.points[1][0];
		let y2 = this.points[1][1];

		let frac1 = this.cells[x1][y1].getFraction();
		let frac2 = this.cells[x2][y2].getFraction();
		if (frac1.value() < frac2.value()) {
			let tmp = frac1;
			frac1 = frac2;
			frac2 = tmp;
		}

		if (this.operation === "/") {
			groupValue = frac1.divide(frac2);
		} else {
			groupValue = frac1.subtract(frac2).reduce();
		}

	} else if (this.operation === "*") {
		groupValue = new Fraction(1, 1);
		for (let i = 0; i < this.points.length; i++) {
			let x = this.points[i][0];
			let y = this.points[i][1];
			groupValue = groupValue.multiply(this.cells[x][y].getFraction());
		}

	} else if (this.operation === "+") {
		groupValue = new Fraction(0, 1);
		for (let i = 0; i < this.points.length; i++) {
			let x = this.points[i][0];
			let y = this.points[i][1];
			groupValue = groupValue.add(this.cells[x][y].getFraction());
		}
	}

	if (groupValue.equals(this.goal)) {
		this.valid();
		return true;
	} else {
		this.invalid();
		return false;
	}
}

/** Displays all member cells as valid */
Group.prototype.valid = function() {
	for (let i = 0; i < this.points.length; i++) {
		let x = this.points[i][0];
		let y = this.points[i][1];
		this.cells[x][y].valid();
	}
}

/** Displays all member cells as invalid */
Group.prototype.invalid = function() {
	for (let i = 0; i < this.points.length; i++) {
		let x = this.points[i][0];
		let y = this.points[i][1];
		this.cells[x][y].invalid();
	}
}